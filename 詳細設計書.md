# PolyCanvas 詳細設計書（v1.0）

## 0. 前提

- 対象：フロントエンド Web アプリ（SPA）
- バックエンド：なし（保存なし）。幾何学模様はクライアント側で生成。
- 永続化：なし（リロードで新規開始）


---

# 1. 画面構成と遷移

## 1.1 画面一覧

1. **LandingScreen**（開始前）
2. **CanvasScreen**（体験）
3. **ResultScreen**（完了）

## 1.2 遷移

- Landing → START → 幾何模様生成 → Canvas
- Canvas →  
  - 全セル塗り終え → 自動 → Result  
  - 「この状態で終える」→ Result（任意終了）
- Result → （終了のみ、再開なし）


---

# 2. コンポーネント構造（React想定）

## 2.1 App（ルート）

State:
```ts
{
  screen: 'landing' | 'canvas' | 'result',
  session: PolyCanvasSession | null
}
```

## 2.2 主要コンポーネント

- `<LandingScreen />`
- `<CanvasScreen />`
- `<ResultScreen />`
- `<ColorPalette />`
- `<CanvasRenderer />`（Canvas 描画）
- `<ConfirmDialog />`


---

# 3. 型定義

## 3.1 基本型

```ts
type Vec2 = { x: number; y: number };

type Cell = {
  id: number;
  polygon: Vec2[];         // 頂点列（0〜1 正規化）
  centroid: Vec2;
  painted: boolean;
  colorIndex: number | null;
};

type PolyCanvasMeta = {
  seed: number;
  cellCount: number;
  bounds: { minX: number; maxX: number; minY: number; maxY: number };
};

type PaletteColor = {
  index: number;    // 0〜15
  hex: string;      // "#RRGGBB"
};

type PolyCanvasSession = {
  meta: PolyCanvasMeta;
  cells: Cell[];
  center: Vec2;
  visibilityLevel: number; // 0〜8
  visibleDistanceThreshold: number;
  paintedCount: number;
  totalCells: number;
  finished: boolean;
  finishReason: 'auto' | 'manual' | null;
  palette: PaletteColor[];
};
```


---

# 4. 幾何学模様生成（詳細仕様）

## 4.1 生成手順

1. ランダムシード決定（URL ?seed=xxx 優先）
2. Poisson Disk Sampling（100〜200点）
3. Voronoi 分割
4. 小セル・巨大セル・細長セルの補正
5. 重心計算
6. 中心付近のセル数チェック（6セル未満なら再生成）
7. PolyCanvasSession 初期化


---

# 4.2 Poisson Disk Sampling

- 領域：`[0,1] × [0,1]`
- 生成点数：100〜200
- 最小距離：0.04

```ts
function generatePoissonPoints(seed: number): Vec2[] {
  // seeded RNG を使用
  // Poisson Disk を実装 or ライブラリ使用
}
```


---

# 4.3 Voronoi 分割

ライブラリ推奨：**d3-delaunay**

```ts
import { Delaunay } from "d3-delaunay";

function buildVoronoi(points: Vec2[]): Vec2[][] {
  const coords = points.flatMap(p => [p.x, p.y]);
  const delaunay = Delaunay.from(coords);
  const voronoi = delaunay.voronoi([0, 0, 1, 1]);

  return points.map((_, i) => {
    const polygon = voronoi.cellPolygon(i);
    return polygon.map(([x, y]) => ({ x, y }));
  });
}
```


---

# 4.4 形状補正ルール

## 4.4.1 最小面積フィルタ

- A_min = 1/700 付近
- 面積が小さいセルは「最も近いセル」と統合

```ts
function mergeSmallCells(cells: Cell[], A_min: number): Cell[] {
  // 1: 面積 < A_min のセルを探索
  // 2: 重心距離が最も近いセルを探す
  // 3: 多角形結合（Union）または Merge 判定
}
```

※ Union 演算を簡略化するため、MVP では「小セルを削除し近隣セルへ吸収扱い」でもよい。


---

## 4.4.2 細長セルフィルタ

```ts
function isTooElongated(poly: Vec2[]): boolean {
  const xs = poly.map(p => p.x);
  const ys = poly.map(p => p.y);
  const w = Math.max(...xs) - Math.min(...xs);
  const h = Math.max(...ys) - Math.min(...ys);
  return Math.max(w, h) / Math.min(w, h) > 3.0;
}
```


---

## 4.4.3 境界巨大セルの抑制

- 「中心からの距離 > 0.9」かつ
- 面積が平均の 5 倍超
- → 統合または削除再生成


---

# 4.5 重心計算

```ts
function centroid(poly: Vec2[]): Vec2 {
  let area = 0;
  let cx = 0;
  let cy = 0;

  for (let i = 0; i < poly.length; i++) {
    const p1 = poly[i];
    const p2 = poly[(i + 1) % poly.length];
    const cross = p1.x * p2.y - p2.x * p1.y;
    area += cross;
    cx += (p1.x + p2.x) * cross;
    cy += (p1.y + p2.y) * cross;
  }

  area *= 0.5;
  const factor = 1 / (6 * area);
  return { x: cx * factor, y: cy * factor };
}
```


---

# 4.6 中心付近セル数保証

- 中心 (0.5, 0.5)
- 半径 0.1
- セルが 6 個未満 → 再生成


---

# 5. 視野仕様（距離ベース）

## 5.1 初期視野

- 距離 ≤ 7%

```ts
function isVisible(cell: Cell, center: Vec2, threshold: number): boolean {
  const dx = cell.centroid.x - center.x;
  const dy = cell.centroid.y - center.y;
  return Math.sqrt(dx * dx + dy * dy) <= threshold;
}
```


## 5.2 視野距離閾値（8段階）

| レベル | 閾値 |
|-------|------|
| 0 | 0.07 |
| 1 | 0.11 |
| 2 | 0.15 |
| 3 | 0.20 |
| 4 | 0.30 |
| 5 | 0.45 |
| 6 | 0.65 |
| 7 | 0.85 |
| 8 | 1.00 |


## 5.3 視野拡大トリガー（塗り割合）

| レベル | 割合 |
|-------|------|
| 1 | 3% |
| 2 | 6% |
| 3 | 10% |
| 4 | 16% |
| 5 | 24% |
| 6 | 34% |
| 7 | 50% |
| 8 | 70% |



---

# 6. 不可逆操作と誤タップ対策

## 6.1 不可逆（塗り直し不可）

```ts
function paintCell(cell: Cell, colorIndex: number): Cell {
  if (cell.painted) return cell; // 何も変更しない
  return { ...cell, painted: true, colorIndex };
}
```

## 6.2 誤タップ対策

### PC：hover
- マウスオーバー中のセルを半透明枠で表示

### モバイル：短い長押し（0.18〜0.22秒）
- touchstart → セルハイライト  
- 長押し時間経過 → 塗り確定  
- touch-action: none でブラウザの選択メニューを抑止


---

# 7. カラーパレット（16色）

```ts
const PALETTE: PaletteColor[] = [
  { index: 0,  hex: "#000000" },
  { index: 1,  hex: "#4B4B4B" },
  { index: 2,  hex: "#808080" },
  { index: 3,  hex: "#C8C8C8" },
  { index: 4,  hex: "#E53935" },
  { index: 5,  hex: "#FB8C00" },
  { index: 6,  hex: "#FDD835" },
  { index: 7,  hex: "#43A047" },
  { index: 8,  hex: "#1E88E5" },
  { index: 9,  hex: "#5E35B1" },
  { index: 10, hex: "#8E24AA" },
  { index: 11, hex: "#D81B60" },
  { index: 12, hex: "#6D4C41" },
  { index: 13, hex: "#F06292" },
  { index: 14, hex: "#7CB342" },
  { index: 15, hex: "#29B6F6" },
];
```


---

# 8. Canvas 描画仕様

## 8.1 基本ルール

1. Canvas の中央に 1:1 の描画領域を確保
2. 各セルの polygon を塗り潰し or グレー表示
3. 可視セル → 塗り or 無塗り（白背景）
4. 不可視セル → マスク（暗転 or 透明）

## 8.2 描画手順（1フレーム分）

```ts
function render(session: PolyCanvasSession, ctx: CanvasRenderingContext2D) {
  clearCanvas(ctx);

  for (const cell of session.cells) {
    const visible = isVisible(cell, session.center, session.visibleDistanceThreshold);

    ctx.beginPath();
    drawPolygon(ctx, cell.polygon);

    if (!visible) {
      ctx.fillStyle = "#222"; // マスク
      ctx.fill();
      continue;
    }

    if (cell.painted) {
      ctx.fillStyle = session.palette[cell.colorIndex].hex;
      ctx.fill();
    } else {
      ctx.fillStyle = "#FFFFFF";
      ctx.fill();
    }

    ctx.strokeStyle = "#00000022";
    ctx.lineWidth = 1;
    ctx.stroke();
  }
}
```

---

# 9. 終了処理

## 9.1 自動終了
- `paintedCount === totalCells`  
→ `finished = true`  
→ `finishReason = 'auto'`  
→ ResultScreen へ遷移

## 9.2 任意終了
- ボタン押下 → 確認ダイアログ → `finishReason='manual'`

---

# 10. SNS共有

## 10.1 出力画像
- 1080×1080 PNG  
- 白 or 黒背景  
- 右下に "PolyCanvas" の小ロゴ

## 10.2 X共有

```text
PolyCanvas で色の地図を描き終えました。
#PolyCanvas
```

## 10.3 Instagram
- 画像DLのみ


---

# 11. 非機能要件

- 400セル描画で 30fps 以上
- スマホ Safari/Chrome 対応
- リロード時は必ず新規模様（保存なし）
- 個人情報の取り扱いなし

---

# 12. 実装者（Claude Code）向けポイント

- まずは **seed固定** で生成 → 動作確認  
- Voronoi → 形状補正 → 重心 → 即描画 の順で進む  
- Polygon union の実装負荷が高い場合  
  - 小セル統合を「小セル削除＋近隣セルへ付け替え」で代用可  
- 描画は Canvas 全再描画でOK（最適化は後回し）  
- スマホ長押し検出は「touchstart → setTimeout → touchend」方式で確実に

---

# 以上、PolyCanvas 詳細設計書（v1.0）
